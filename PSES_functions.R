# 2020 documentation
# https://open.canada.ca/data/dataset/4301f4bb-1daa-4b50-afab-d1193b5d2284/resource/25076d6a-84c0-48d0-97a9-f9d20ec2a10d/download/2020-pses-supporting-documentation_document-de-reference-du-saff-2020.xlsx
# 2020 data
# https://open.canada.ca/data/dataset/4301f4bb-1daa-4b50-afab-d1193b5d2284/resource/8bf75d4b-a80d-4828-839a-bf8c0b76af51/download/2020-public-service-employee-survey-open-dataset-ensemble-de-donnees-ouvertes-du-sondage-aupres-.csv

# source("PSES_functions.R")
# Trying to fix July 6 2019

# libraries & functions ------
if (T) {
  library(data.table, quietly=T)
  options(datatable.print.class=TRUE)
  #library(tidyverse) # includes: 
  library(readxl)
  library(magrittr)
  library(lubridate,  quietly=T)
  options(lubridate.week.start =  1)
  library(stringr)
  #library(tibble)
  library(ggplot2)
  library(png)
  image_smileys <- readPNG("feedback2.png")
  library(data.tree)
  
  
  getmode <- function(v) {   # mode
    uniqv <- unique(v)
    uniqv[which.max(tabulate(match(v, uniqv)))]
  }
  
  dt.getRows <- function(dt, rows) {     
    dt[rows]   }
  dt.getCols <- function(dt, columns) {
    if (column %>% is.integer() ) column <- names(dt)[column]
    dt[, .SD, .SDcols = column]  }
  
  if (F) { # TODO
    dt.getFor <- function(dt, keyed_values, upto=Inf, keys=NULL) {
      upto <- min(length(keyed_values, upto))
      keys <- ifelse(is.null(keys), dt %>% names, keys)
      setkeyv(dt, keys[1:upto])
      dt[as.list(keyed_values)]
    }
    
    # get children
    dt.getFor(dtDepartments, id[1:myLevel],keys=PSES_ID_COLS[1:myLevel])
    dt.getFor(dtDepartments, id[1:myLevel],upto=myLevel, keys=PSES_ID_COLS)
  }
}



# GLOBALS(<<-): dtPSES, dtQuestions, dtDepartments ----


# TODO: Later all this should be renames from my* to pses.*
# TODO: In Best OOP practices, this should be a Structure(aka List in R) or (better) R6 Class !!

# so we'll have 
#     pses$dtRESULTS, etc
# pses$init <- function()  {} # CPses$ 
# pses$init (). For now they need to be GLOBAL, so to use <<-


if (T) {  
  
  PSES_ID_COLS = c("LEVEL1ID"  ,   "LEVEL2ID"    , "LEVEL3ID"   ,  "LEVEL4ID"   ,  "LEVEL5ID"  ); psesKeys = PSES_ID_COLS; COLS_PSES = PSES_ID_COLS
  
  bPSES_READ <- F
  dtPSES <- data.table(); dtQuestions <- data.table(); dtDepartments <- data.table();  
  dtAll <- data.table();
  dtResultsAll <- data.table(); dtRESULT <- data.table();  
  # dtDeptSelected <- data.table();  
  

  myID0 = c(83,200,304,418,0)
  myID = myID0
  myLevel=1 #getLevel(myID)
  myQ <- "Q43"
  myQs <- c("Q43", "Q42")
  myYears <- c(2018)
  myYear <- 2018
  myOrg <- "Science and Engineering"
  
  #TODO : change above to below 
  my <- list();  my$ID <- myID; my$Q <- myQ; my$Year <- myYear
  
  input <- list()
  pses.selectInput <- function( myID=myID0,year=2018,nQ=myQ  ){
    input$year <<- year;
    input$question <<- dtQuestions[QUESTION==myQ]$Question.Abbreviated
    input$level1 <<- myID[1];
    input$level2 <<- myID[2]
    input$level3 <<- myID[3];
    input$level4 <<- myID[4]; 
    input$level5 <<- myID[5];  #".ALL COMBINED."
    
    input$sortby <<- "rank"
    input$overlay <<- "number of responses"
    input$filterbyrank <<- c(50,100)
    input$filterbygradient <<-c(-100,100)
    input$showparents <<- T
    input$showchildren <<- T
    
  }
  if (F) {
    pses.selectInput (); input
  }
  
  my <- list()
  my.update  <- function(){
    my$ID <<- c(input$level1, input$level2, input$level3, input$level4, input$level5)
    gsub(".ALL COMBINED.", "0", my$ID)
    my$Q <<- dtQuestions[Question.Abbreviated == input$question]$QUESTION
    my$Year <<- myYear
    my$Org <<- myOrg
  }
  if (F) {
    my.update  (); my
  }
  
  
  OPEN_CANADA_URL <- "https://www.canada.ca/content/dam/tbs-sct/documents/datasets/pses-saff/2018/2018_PSES_open_dataset_Ensemble_de_donn%C3%A9es_ouvertes_du_SAFF_2018.csv"
  
  
  #strCaptionCredits <- "Open Government Licence - Canada (https://open.canada.ca)"
  strCaptionCredits <-  paste0("2018 Public Service Employee Survey Results.\n License: Open Government Licence - Canada\n Generated on ", format(Sys.time(), "%d %B, %Y"), " by iTrack (https://itrack.shinyapps.io/PSES)")
  
  # strCaptionCredits <-  'Generated by iTrack (https://itrack.shinyapps.io/PSES)\nLicense: Open Government Licence - Canada'
  
  #  strCaptionCredits <- "Data  Source: https://open.canada.ca"
  strTitle <- NULL
  strSubtitle <- NULL
  
}

# PSES functions -----
ID2IDk <- function(...) { getIDupto(...) }
getIDupto <- function (id=myID, l=3) {
  # if (is.null(id))      id <-  myID
  if(l==0) {       return(rep(0,5))     } 
  if (l==5) {      return(id)
  } else {      c(id[1:l],rep(0,5-l)) 
  }
}
getIDupto()
getIDupto(c(28,34,604,10,255),3)  

ID2IDlevel <- function(...) { getLevel(...) }
getLevel <- function(id=myID) {
  which.min(id) - 1
}
getLevel()

Org2ID <- function(str=myOrg) {
  if(nrow(dtDepartments)!=0) {
    dtDepartments[Organization == str, (PSES_ID_COLS),with=F] %>% unlist;
    #return(  dtDepartments[ Organization==str, .(LEVEL1ID, LEVEL2ID, LEVEL3ID, LEVEL4ID,LEVEL5ID) ] %>% unlist() )
  }
}
Org2ID() 

ID2Org <- function(id=myID) {
  if(nrow(dtDepartments)!=0) {
    setkeyv(dtDepartments,PSES_ID_COLS)
    return(dtDepartments[as.list(id)]$Organization)
  }
}
ID2Org()

ID2Path <- function(id=myID) {
  if(nrow(dtDepartments)!=0) {
    setkeyv(dtDepartments,PSES_ID_COLS)
    return(dtDepartments[as.list(id)]$pathString)
  }
}


# getDept Children W/O (or WITH) yourself !
getDeptChildren<- function (id = myID, depth=Inf, yourself=F){
  if(nrow(dtDepartments)==0) return (NULL)
  
  setkeyv(dtDepartments, PSES_ID_COLS)
  levelID <- dtDepartments[as.list(id)]$IDlevel
  
  if (levelID==0)
    dt <- dtDepartments
  else {
    setkeyv(dtDepartments, PSES_ID_COLS[1:levelID])
    dt <- dtDepartments[as.list(id[1:levelID])]
    # OR dt <- dtDepartments[.(id[1:levelID])]  ????
  }
  if (!yourself) 
    dt <- dt [level!=levelID]
  
  dt <- dt [level<=levelID+depth]
  return(dt)
}
getDeptChildren()

# getDept Parents AND yourself !
getDeptParents <- function ( id = myID) {
  if(nrow(dtDepartments)==0) return (NULL)
  
  dtDepartments[
    (LEVEL1ID == 0 | LEVEL1ID == id[1] ) & 
      (LEVEL2ID == 0 | LEVEL2ID == id[2]) & 
      (LEVEL3ID == 0 | LEVEL3ID == id[3]) & 
      (LEVEL4ID == 0 | LEVEL4ID == id[4] )& 
      (LEVEL5ID == 0 | LEVEL5ID == id[5]  ) 
    ] 
}
getDeptParents()

getDeptAboveBelow <- function ( id = myID ) {
  rbind(getDeptParents(id),getDeptChildren(id))
}

# TODO rename : selectDepts -> selectDeptTree Or  getDeptsAboveBelow ()
selectDeptTree <- function ( id = myID) {
  
  if (  bPSES_READ==F) {
    print('getRESULTS(): PSES data NOT initialized ! -  Please Run readPsesData()')
    return (dtRESULT)
  } 
  
  myID <<- id
  # levelID <- dtDepartments[as.list(id)]$IDlevel
  myLevel <<- getLevel(myID)
  # setkeyv(dtDepartments, PSES_ID_COLS)
  # .levelID <- dtDepartments[as.list(id)]$IDlevel; 
  # .levelID <- myLevel
  
  if (myLevel==0) {
    dtDeptSelected <<- dtDepartments 
    return(dtDeptSelected)
  }
  
  setkeyv(dtDepartments, PSES_ID_COLS[1:myLevel]) 
  dtDeptSelected <<- 
    
    dtDepartments[as.list(id[1:myLevel])] %>% # get ALL children
    
    rbind(dtDepartments[                      # add ALL parents
      (LEVEL1ID == 0 | LEVEL1ID == id[1] ) & 
        (LEVEL2ID == 0 | LEVEL2ID == id[2]) & 
        (LEVEL3ID == 0 | LEVEL3ID == id[3]) & 
        (LEVEL4ID == 0 | LEVEL4ID == id[4] )& 
        (LEVEL5ID == 0 | LEVEL5ID == id[5]  ) 
      ] ) %>% unique()
  
  # setkeyv(dtDeptSelected, c(PSES_ID_COLS,"IDlevel"))
  setkeyv(dtDeptSelected, c(PSES_ID_COLS))
  
  return(dtDeptSelected)
}



getRESULTS <- function(id = c(83,200,304,0,0), aQs=c("Q43"), aYears=c(2018),depth=1) {
  if (  bPSES_READ==F) {
    print('getRESULTS(): PSES data NOT initialized ! -  Please Run readPsesData()')
    return (dtRESULT)
  }
  
  selectDepts (id)
  
  # dtRESULT <<- dtPSES[SURVEYR %in% aYears][
  #   selectDepts (id), on=PSES_ID_COLS][IDlevel<=levelID+depth][
  #     dtQuestions[QUESTION %in% aQs], on="QUESTION"]
  
  dtRESULT <<- dtPSES[SURVEYR %in% aYears][
    dtDeptSelected, on=PSES_ID_COLS][
      dtQuestions[QUESTION %in% aQs], on="QUESTION"]
  
  # dtRESULT <<- dtRESULT 
  
  setkeyv(dtRESULT, c(PSES_ID_COLS, "SURVEYR", "QUESTION"))
  
  if (dtRESULT[.N]$IDlevel == 0)
    dtRESULT <<-  dtRESULT[which.max(ANSCOUNT)]
  else {
    dtRESULT <<-  dtRESULT [, ':='(SCORE100=median(SCORE100), ANSCOUNT=max(ANSCOUNT)) ,
                            by=.(SURVEYR,QUESTION,Organization)] %>%
      unique(by=c("SURVEYR","QUESTION","Organization"))
  }
  #   
  
  # TO DO LATER - DO IT IN PSES !  FIX IT !!!
  # dt <- dtRESULT [, .(SCORE100=median(SCORE100), ANSCOUNT=max(ANSCOUNT)) , 
  #                by=.(SURVEYR,QUESTION,Organization)]
  # setkey(dt,Organization )
  # setkey(dtRESULT,Organization )
  # dtRESULT <- dtRESULT [dt] 
  # dtRESULT <- dtRESULT[, SURVEYR:Question.Abbreviated]
  
  
  
  return(dtRESULT)
}


if (F) { # NOT DONE
  #ID2OrgTree
  ID2OrgAboveBelow <- function(id) {
  }
  
  ID2IDAboveBelow
  selectDeptTree(myID)
  
  setkeyv(dtDepartments, PSES_ID_COLS[1:myLevel])    
  
  dtDeptSelected <<- 
    dtDepartments[as.list(id[1:myLevel])] %>% # get ALL children
    
    rbind(dtDepartments[                      # add ALL parents
      (LEVEL1ID == 0 | LEVEL1ID == id[1] ) & 
        (LEVEL2ID == 0 | LEVEL2ID == id[2]) & 
        (LEVEL3ID == 0 | LEVEL3ID == id[3]) & 
        (LEVEL4ID == 0 | LEVEL4ID == id[4] )& 
        (LEVEL5ID == 0 | LEVEL5ID == id[5]  ) 
      ] ) %>% unique()
  
}



#............................................................. ----

createPsesDepartments <- function() {
  
  # strUrlDocumentation2018local  <- "source-data/2018_PSES_Supporting_Documentation_Document_de_référence_du_SAFF_2018.xlsx" # 2018 code 
  strUrlDocumentation2020local <- "source-data-2020/2020-pses-supporting-documentation_document-de-reference-du-saff-2020.xlsx" # 2020 code
  # dtDepartments <- read_excel(strUrlDocumentation2018local, sheet=6) %>% data.table(); # 2018 code
  dtDepartments <- read_excel(strUrlDocumentation2020local, sheet=7) %>% data.table(); # 2020 code
  
  dtDepartments
  dtDepartments[, .N]; dtDepartments %>% names
  # dtDepartments$`DESCRIPTION FR` <- NULL # 2018 code
  dtDepartments$`Liste des unités organisationnelles` <- NULL # 2020 code
  dtDepartments$`Number of employees / Nombre d'employés` <- NULL # 2020 code
  dtDepartments$`...9` <- NULL # 2020 code
  # setnames(dtDepartments, old="DESCRIPTION ENG", new="Organization") # 2018 code
  setnames(dtDepartments, old = "Organizational unit list", new = "Organization") # 2020 code
  dtDepartments[1]
  cols <- c("LEVEL1ID", "LEVEL2ID", "LEVEL3ID", "LEVEL4ID", "LEVEL5ID" )
  cols=1:5; 
  dtDepartments[, (cols):=lapply(.SD, as.integer), .SDcols=cols]; 
  
  
  # . Add PS (0.0.0.0.0)  ----
  dtDepartments <- dtDepartments %>% rbind(data.table(0L,0L,0L,0L,0L,"Public Service"), use.names=F)
  
  #. Truncate Dept name  -----
  dtDepartments$Organization.fullname <- dtDepartments$Organization
  dtDepartments[ , Organization:= Organization %>% str_trunc(50,side="center", ellipsis = "...") ]
  
  #. Replace `-`` to `/`` -----
  dtDepartments$Organization<- gsub("/", "-", dtDepartments$Organization ) 
  
  # . Add Acronyms (AADD) -----
  dtDepartments$AADD <-  abbreviate(dtDepartments$Organization, 1, named = FALSE)
  
  #NB: some Acronyms are the same !
  dtDepartments[, .(AADD,Organization)] #2404
  dtDepartments[, .(AADD,Organization)] %>% unique() # 2177: 
  
  for (i in 1:5) dtDepartments[, AADD := str_replace (AADD, '\\(', "")] 
  
  dtDepartments[, AADD := str_replace (AADD, "[[:lower:]]+", "")] 
  dtDepartments$AADD <- str_replace(dtDepartments$AADD, "[[]:punct:]]+", "")
  
  #for (i in 1:5) dtDepartments[, AADD := str_replace (AADD, "[:lower:]+", "")] 
  #for (i in 1:5) dtDepartments$AADD <- str_replace(dtDepartments$AADD, "[:punct:]+", "")
  #  dtDepartments[AADD == "I", AADD:= "N.A."]
  dtDepartments[AADD == "I", AADD:= "N/A"]
  
  
  
  # . Add IDlevel ----
  dtDepartments[ , IDlevel:=ifelse(LEVEL1ID == 0, 0, 
                                   ifelse(LEVEL2ID == 0, 1, 
                                          ifelse(LEVEL3ID == 0, 2, 
                                                 ifelse(LEVEL4ID == 0, 3, 
                                                        ifelse(LEVEL5ID == 0, 4, 5)))))]
  
  # . factor(dtDepartments$IDlevel----
  dtDepartments$IDlevel <- factor(dtDepartments$IDlevel,  levels = order(dtDepartments$IDlevel,decreasing=T))
  
  
  
  # . pathString: ORG_, LEV_  CBSA-HQ-ISTB-SED  ----
  
  if(T) {
    
    for (i in 1:nrow(dtDepartments))  {
      # if (dtDepartments[i,]$LEVEL2ID==999 | dtDepartments[i,]$LEVEL2ID==0)
      #   next;
      id <- dtDepartments[i, (PSES_ID_COLS),with=F] %>% unlist; id
      # if (getLevel(id)==0) 
      #   next
      ll <- getLevel(id);ll
      getIDupto(id,ll)
      
      #    dtDepartments[i, BB_DD:=""]
      setkeyv(dtDepartments, PSES_ID_COLS)
      
      for (l in 0:getLevel(id)) {
        # for (l in 1:getLevel(id)) {
        x <- dtDepartments[as.list(getIDupto(id,l))]$AADD ; #x %>% print
        xx <- dtDepartments[as.list(getIDupto(id,l))]$Organization.fullname %>% 
          str_trunc(40,ellipsis = "...")
        dtDepartments[i, paste0("LEV_", l):= x]
        dtDepartments[i, paste0("ORG_", l):= xx]
      }
    }
    
    dtDepartments[ , pathString:=paste(LEV_1, LEV_2,LEV_3,LEV_4, sep = "/")]
    for (i in 1:5) dtDepartments[, pathString := str_replace (pathString, '/NA', "")] 
    
    # dtDepartments[IDlevel==0, pathString:="All Public Service"]
    # dtDepartments[IDlevel==1, pathString:=AADD]
  }
  
  # . Order by Key and Add order number: .I -----
  setkeyv(dtDepartments, PSES_ID_COLS)
  dtDepartments[, I:= .I]
  
  # .[ remove 999. ie. "I can't find my unit"] -----
  
  # .. Test Uniqueness of names,Org,pathString-----
  dtDepartments %>% nrow() # [1] 2404 (2018), [1] 3679 (2020)
  dtDepartments$Organization %>% unique() %>% length()# [1] 2177 (2018), [1] 3354 (2020)
  dtDepartments$pathString %>% unique() %>% length()# [1] 2206 2267 (2018), [1] 3187 (2020)
  dtDepartments$AADD %>% unique() %>% length()# [1] 1997 (2018), [1] 2936 (2020)
  
  samePaths <- dtDepartments[, .N, by=pathString][N>1]$pathString
  dtDepartments[pathString %in% samePaths]
  
  #. [ order decreasing = T ] ----
  # dtDepartments <- dtDepartments[order(Organization, decreasing = T)]
  
  # . Save -----
  dtDepartments[,.N];   dtDepartments %>% names
  dtDepartments[c(1,.N)]
  dtDepartments[LEVEL1ID==83]
  fwrite(dtDepartments, "dtDepartments.csv", sep="\t"); 
  #dtDepartments <- fread("dtDepartments.csv")
}
#. createPsesDepartments ----
if (F)
  createPsesDepartments()

#.................................................... ----

createPsesQuestions <- function() {
  
  strUrlDocumentation2018local  <- "source-data/2018_PSES_Supporting_Documentation_Document_de_référence_du_SAFF_2018.xlsx"
  # strURLDocumentation2020local <- "source-data-2020/2020-pses-supporting-documentation_document-de-reference-du-saff-2020.xlsx"
  dtQuestions <- read_excel(strUrlDocumentation2018local, sheet=3) %>% data.table();
  # dtQuestions <- read_excel(strUrlDocumentation2020local, sheet=3) %>% data.table();
  
  dtQuestions[,.N];   dtQuestions %>% names
  dtQuestions$Français <- NULL
  setnames(dtQuestions, c("QUESTION", "Question"))
  
  assignThemesToQuestions <- function(.dtQuestions) {
    
    # lThemes: 36 main questions :  22 + 5+ 4 + 5 
    # 43: Would you recommend
    
    lTheme <- list()
    
    # OLD THEMES 2018
    lTheme[[6]] <- list(Qs=c("Q06", "Q18", "Q19", "Q20"), str = "Performance management")
    lTheme[[5]] <- list(Qs=c("Q23", "Q24", "Q26"), str = "My Immediate Supervisor")
    lTheme[[4]] <- list(Qs=c("Q28", "Q29", "Q30", "Q31", "Q32"), str = "Senior Management") # ==
    lTheme[[3]] <- list(Qs=c("Q33", "Q34", "Q36", "Q37", "Q40"), str = "Ethical Workplace")
    lTheme[[2]] <- list(Qs=c("Q41",  "Q44", "Q45", "Q64","Q65"), str = "Respectful & Healthy Workplace") #"Q42", "Q43",
    lTheme[[7]] <- list(Qs=c("Q48","Q54","Q55","Q60",'Q61'), str ="Harassment & Discrimination") #

    lTheme[[1]] <- list(Qs=c("Q42","Q43","Q44","Q63",'Q66'), str ="Stress and Overall") # Overall Environment"

    lTheme[[8]] <- list(Qs=c("Q67","Q71",'Q72', "Q73"), str ="Phoenix & Pay issues") # "70"
    
    # NEW THEMES 2020 # TODO
    
    
    # dtPSES[str_length(QUESTION)<=3 & SCORE100>100, .N, QUESTION]$QUESTION 
    # [1] "Q46", "Q47", "Q69", "Q70"  
    # 
    if (F) {
      
      # REDUNDANT 
      aQuestions22 <- c("Q06", "Q18", "Q19", "Q20", 
                        "Q23", "Q24", "Q26", 
                        "Q28", "Q29", "Q30", "Q31", "Q32", 
                        "Q33", "Q34", "Q36","Q37", "Q40", 
                        "Q41", "Q42", "Q43", "Q44", "Q45",
                        
                        "Q48","Q54","Q55","Q60",'Q61',
                        "Q63","Q64","Q65","Q66",
                        "Q67","Q71",'Q72', "Q73"
      )
    }
    
    
    
    for (i in 1:length(lTheme)) {
      .dtQuestions[ QUESTION %in% lTheme[[i]]$Qs, ':='(Theme=lTheme[[i]]$str, nTheme=i)]
    }
    
    .dtQuestions
  }
  
  
  # . assign Themes ----
  dtQuestions <- assignThemesToQuestions(dtQuestions)
  dtQuestions <- dtQuestions[!is.na(Theme)] # LEave only OUR 35 questions
  dtQuestions$Question %>% unique()
  
  # . clean, abbreviate ----
  for (i in 1:4) dtQuestions[, Question := str_replace (Question, '\\n+', " ")] 
  for (i in 1:4) dtQuestions[, Question := str_replace (Question, '\\r+', " ")]
  
  dtQuestions$Question.Abbreviated <- gsub("Question ", "", dtQuestions$Question) %>% str_trunc(90,ellipsis = "..") 
  
  if (F) {
    dtQuestions[, Question.Abbreviated := str_replace (Question.Abbreviated, '[:digit:]+', "")]
    dtQuestions[, Question.Abbreviated := str_replace (Question.Abbreviated, '. ', "")]
  }
  
  dtQuestions$Question <- dtQuestions$Question %>% str_trunc(158,ellipsis = "..") 
  
  if (F) {
    dtQuestions$Question <- dtQuestions$Question %>% 
      str_wrap(90, exdent=2)
  }
  #   #thanks <- word(thanks, 1, 3, fixed("\n\n")) # to break by end of line
  
  
  # . Sort: Add factor to sort----
  if (T) { 
    dtQuestions$Question <- factor(dtQuestions$Question, 
                                   levels = dtQuestions$Question[order(dtQuestions$nTheme)])
    dtQuestions$QUESTION <- factor(dtQuestions$QUESTION, 
                                   levels = dtQuestions$QUESTION[order(dtQuestions$nTheme)])
    # WORKS
    dtQuestions$Question.Abbreviated <- factor(dtQuestions$Question.Abbreviated, 
                                               levels = dtQuestions$Question.Abbreviated[order(dtQuestions$nTheme)])
    #dtQuestions[ , Question.Abbreviated := ordered(Question.Abbreviated, levels = Question.Abbreviated[order(nTheme)])  ]
    
    
    #dtQuestions$Question.Abbreviated <- as.character(dtQuestions$Question.Abbreviated)
    #dtQuestions <- dtQuestions[order(QUESTION, decreasing = F)]
    #setkey(dtQuestions, -QUESTION)
  }
  
  # . save ----
  setkey(dtQuestions, QUESTION)
  dtQuestions[,.N];   dtQuestions %>% names
  fwrite(dtQuestions, "dtQuestions.csv", sep="\t"); 
  
}
#. createPsesQuestions ----
if (F)
  createPsesQuestions ()

#............................................................... ----

createPsesScores <- function() {
  
  if (F) {  # I. Read 2018 only  ----
    strUrl2018local <- "source-data/2018_PSES_open_dataset_Ensemble_de_données_ouvertes_du_SAFF_2018.csv"
    # strUrl2020local <- "source-data-2020/2020-public-service-employee-survey-open-dataset-ensemble-de-donnees-ouvertes-du-sondage-aupres-.csv"
    dtPSES <<- fread(strUrl2018local);
    # dtPSES <<- fread(strUrl2020local); 
    
    if (T) { # . Keep 2018 only 
      dtPSES[ , .N, by = SURVEYR]
      dtPSES[SURVEYR == 2018 ] # 1062480 # 2018 code
      # dtPSES[SURVEYR == 2020 ] # 1751221 # 2020 code
      ## dtPSES <<- dtPSES [SURVEYR==2018] 
    }
  } else { # II. Read 2011-2018 files ---- 
    
    # THIS NEEDS TO BE VALIDATED
    
    
    ########################################################### #
    #  0.Read dtQmapping  ---- 
    ########################################################### #
    #Question number concordance with past surveys
    
    #https://www.canada.ca/en/treasury-board-secretariat/services/innovation/public-service-employee-survey/2018/question-number-concordance-past-surveys-2018.html
    
    if (F) {
      strFile <- "source-data/PSES-SED-2011-2018.xls" 
      dtQmapping <- read_excel(strFile, sheet=4) %>% data.table()
      
      cols <- c("n2018", "n2017","n2017a","n2014","n2011","n2008")
      setnames(dtQmapping,c("Question", cols))
      
      # for (c in cols) {
      #   dtQmapping[as.name(c)=="N/A", c:=NA]
      # }
      dtQmapping  
      
      fwrite(dtQmapping, "dtQmapping.csv", sep="\t"); 
    } else{
      dtQmapping <- fread("dtQmapping.csv"); 
    }
    
    cols <- c("n2018", "n2017","n2017a","n2014","n2011","n2008")
    dtQmapping[, (cols):=lapply(.SD, as.integer), .SDcols=cols]
    dtQmapping[, (cols):=lapply(.SD, function(x) sprintf("Q%02i",x)), .SDcols=cols]
    dtQmapping[, (cols):=lapply(.SD, function(x) ifelse(x=="QNA", NA, x)), .SDcols=cols]
    dtQmapping
    
    #. Read 2011-2018 .csv data ----
    strUrl2018local <- "source-data/2018_PSES_open_dataset_Ensemble_de_données_ouvertes_du_SAFF_2018.csv"
    strUrl2017local  <- "source-data/2017_PSES_SAFF_Open_dataset_Ensemble_donnees_ouvertes.csv"
    strUrl2014local  <- "source-data/2014-results-resultats.csv"
    strUrl2011local  <- "source-data/2011_results-resultats.csv"
    
    dt2011 <- fread(strUrl2011local); dim(dt2011)# 22 cols
    dt2014 <- fread(strUrl2014local); dim(dt2014)# 23 cols
    dt2017 <- fread(strUrl2017local); dim(dt2017)# 23 cols
    dt2018<- fread(strUrl2018local); dim(dt2018)
    
    
    #. Remove AGREE column in 2014-2018 .csv data ----
    dt2014$AGREE <- NULL
    dt2017$AGREE <- NULL
    dt2018$AGREE <- NULL
    
    
    #. Rename QUESTION column in 2011  so we can merge by it----
    setnames(dt2011, "V9", "QUESTION");     dt2011 %>% names
    
    # . Rename question numbers in each set ----
    dt2018$QUESTION %>% unique #  Q01 2312923: 
    dt2017$QUESTION %>% unique # A_Q01 3289210:  
    dt2014$QUESTION %>% unique# A_Q01 1509724:  
    dt2011$QUESTION %>% unique# A_Q01  1069189: 
    
    dt2017[, QUESTION := QUESTION %>% substring(3)]
    dt2014[, QUESTION := QUESTION %>% substring(3)]
    dt2011[, QUESTION := QUESTION %>% substring(3)]
    
    
    
    # . * Replace question via mapping  ----
    dt2011[
      dtQmapping,
      on = c(QUESTION = "n2011"),
      QUESTION := n2018
      ]
    
    dt2014[
      dtQmapping,
      on = c(QUESTION = "n2014"),
      QUESTION := n2018
      ]
    
    dt2017[
      dtQmapping,
      on = c(QUESTION = "n2017"),
      QUESTION := n2018
      ]     
    
    # . rbind them together (dt2011-2018) ----
    dtPSES <- dt2018 %>% rbind(dt2017) %>% rbind (dt2014) %>% rbind(dt2011, use.names=F)
    
    rm(dt2018);  rm(dt2017);  rm(dt2014);  rm(dt2011); 
  }
  
  # >>> Post Process PSES #######################################################
  ##  
  dtPSES[c(1,.N)]; names(dtPSES) # 23 cols
  dtPSES %>% dim # 8181046      22
  dtPSES$QUESTION %>% unique()
  dtPSES[, .N, by = SURVEYR]
  
  if (T) { # . Leave two-digit questions only  ----
    dtPSES <- dtPSES[str_length(QUESTION)<=3]
  }
  
  if (F) { # .Leave  dtQuestions (22 or 35) only ----
    if (dtQuestions %>% nrow == 0) {
      print("createPsesScores(): dtQuestions has 0 rows!")
    } else {
      dtPSES <- dtPSES [QUESTION %in% (dtQuestions$QUESTION %>% unique)]
    }
  }
  
  # .Leave needed columns only ----
  
  cols <- c("LEVEL1ID", "LEVEL2ID", "LEVEL3ID", "LEVEL4ID", "LEVEL5ID", "SURVEYR", "QUESTION", "ANSWER1",  "ANSWER2",  "ANSWER3",  "ANSWER4",  "ANSWER5", "SCORE100", "ANSCOUNT")
  
  dtPSES <- dtPSES[ , cols, with=F]
  dtPSES %>% names;   dtPSES[1:2]
  
  dtPSES [, .N, by = SURVEYR ]
  dtPSES[SURVEYR == 2018 ] # 1062480 --> 283257:
  dtPSES %>% nrow  # --> 792546      b) 2312923 ,   - 8181046  
  dtPSES %>% unique() # --> 771020 , b) 2237858 , 2237817 - 7187044
  dtPSES <- dtPSES %>% unique() 
  
  if (T){ # . FIX dtPSES[SCORE100>100, QUESTION]----
    dtPSES[SCORE100>100, QUESTION]
    
    dtPSES [QUESTION %in% c( "Q48","Q55"), SCORE100:= ANSWER2  ]
    dtPSES [QUESTION %in% c( "Q48","Q55") & SCORE100>100 ] # 0
    
    dtPSES[str_length(QUESTION)<=3 & SCORE100>100 , SCORE100:= 77]
  }
  
  # >> DEAL / REMOVE UMBIGUOUS (ensure  they are sorted down !  ----
  
  
  if (F) {  # not working
    
    # . handle multiple answers ----    
    dtAll[ ,.N, by=.(SURVEYR,QUESTION,Organization)][N>1] # 1979: 
    
    
    dtAll <<-  dtAll [, ':='(SCORE100=median(SCORE100) %>% as.integer(), ANSCOUNT=max(ANSCOUNT)) ,
                      by=.(SURVEYR,QUESTION,Organization)]
    dtAll <<- dtAll %>% unique(by=c("SURVEYR","QUESTION","Organization"))
  }
  
  dtPSES %>% nrow() # 3278338
  
  #       # 1. WHY Many responses for the same question (cols) in x-0-0-0-0 ??? ----
  #     
  # ... examine the problem ----
  # 
  
  if(F) { 
    
    #myID = c(83,0,0,0,0)
    qq <- quote (LEVEL1ID == 83 & LEVEL2ID == 0 & LEVEL3ID == 0 & LEVEL4ID == 0 & LEVEL5ID == 0 )
    dtPSES[eval(qq)  & SURVEYR==2018 & QUESTION == "Q43"][, .(.N, SCORE100, ANSCOUNT), by=cols][N>1]
    dtPSES[eval(qq) & SURVEYR == 2018 & QUESTION == "Q43"][order(ANSCOUNT, decreasing = T)] [, .(SCORE100,ANSCOUNT)] %>% plot
    
    dtPSES[eval(qq)  & SURVEYR == 2017 & QUESTION == "Q43"][order(ANSCOUNT, decreasing = T)][, .(SCORE100,ANSCOUNT)] %>% plot # 145 rows: 6228
    dtPSES[eval(qq)  & SURVEYR==2017 & QUESTION == "Q43"][, .(.N, SCORE100, ANSCOUNT), by=cols][N>1]
    
    dtPSES[eval(qq) &  LEVEL5ID == 0 & SURVEYR == 2014 & QUESTION == "Q43"][order(ANSCOUNT, decreasing = T)][, .(SCORE100,ANSCOUNT)] %>% plot # 145 rows: 6228
    dtPSES[eval(qq)  & SURVEYR==2014 & QUESTION == "Q43"][, .(.N, SCORE100, ANSCOUNT), by=cols][N>1]  
    
    dtPSES[eval(qq) &  LEVEL5ID == 0 & SURVEYR == 2011 & QUESTION == "Q43"][order(ANSCOUNT, decreasing = T)][, .(SCORE100,ANSCOUNT)] %>% plot # 145 rows: 6228
    dtPSES[eval(qq)  & SURVEYR==2011 & QUESTION == "Q43"][, .(.N, SCORE100, ANSCOUNT), by=cols][N>1]      
    
  }
  remove_extra_rows_with0s_in_LEVELS <- function(dt) {
    
    cols <- c("LEVEL1ID" ,"LEVEL2ID" ,"LEVEL3ID" ,"LEVEL4ID", "LEVEL5ID", "QUESTION", "SURVEYR")
    setkeyv(dtPSES, cols);
    dtPSES[, .N, by=cols] # 74558,  260204: - 83742:  
    dtPSES[, .N, by=cols][N>1] # 6824, 22656 : -  7273: 
    
    setorderv(dtPSES, c(cols, "ANSCOUNT"), c(rep(1,length(cols)), -1))
    #setorder(dt0, -ANSCOUNT);        dt0 # 594 , 625 1153  0-0-0-0-0, 145
    # 
    
    if (T) {
      # ...  Approach 1: Take Score from the largest ANSCOUNT. ----
      #Alternatively, I can recompute  "SCORE100"
      
      
      dtPSES %>% nrow # 771020  , 825479
      dtPSES <<- dtPSES %>% unique(by=cols) # 83742 !!!!
      dtPSES %>% nrow # 74558, 244885 # OR 244742 , 260204 (if  dtPSES [SURVEYR==2018])
      dtPSES [, .N, by = SURVEYR ]
      dtPSES [, .N, by = .(SURVEYR,QUESTION) ]
    }
    if (F) {  # ... Approach 2: take average, median,mode or Maximum ----
    }
    
    if (F) {  # ... [ Alt.approach: recompute ANSCOUNT ----
      
      # dt0 <- dtPSES [LEVEL2ID == 0]
      # for (c in paste0("ANSWER",1:5)) {
      #   dt0[, as.name(paste0(c,"_t")):= as.name(c)*"ANSCOUNT", with=T]
      # }
      # for (c in paste0("ANSWER",1:5)) {
      #   dt0[, get(paste0(c,"_t")):= get(c)*ANSCOUNT,]
      # }
      # dt0[, SCORE100.new:= (100*ANSWER1*ANSCOUNT + 75*ANSWER2*ANSCOUNT + 50*ANSWER3*ANSCOUNT + 25*ANSWER4*ANSCOUNT) / (ANSWER1*ANSCOUNT + ANSWER2*ANSCOUNT + ANSWER3*ANSCOUNT +ANSWER4*ANSCOUNT + ANSWER5*ANSCOUNT), 
      #     by=.(LEVEL1ID, SURVEYR, QUESTION)]
      # 
      # dt0 <- dtPSES [LEVEL2ID == 0, 
      #                SCORE100.new:= (100*ANSWER1*ANSCOUNT + 75*ANSWER2*ANSCOUNT + 50*ANSWER3*ANSCOUNT + 25*ANSWER4*ANSCOUNT) / (ANSWER1*ANSCOUNT + ANSWER2*ANSCOUNT + ANSWER3*ANSCOUNT +ANSWER4*ANSCOUNT + ANSWER5*ANSCOUNT), 
      #                by=.(LEVEL1ID, SURVEYR, QUESTION)]
      
    }
    
  }
  
  dtPSES <- remove_extra_rows_with0s_in_LEVELS(dtPSES)
  
  
  if (F) { # no work
    #. assign rank to each Org for each Q. at each Year ----
    dtPSES$RANK100 <- 50
    
    #setkeyv(dtPSES, c("Organization", "SURVEYR", "QUESTION")
    setkeyv(dtPSES, c(PSES_ID_COLS, "SURVEYR", "QUESTION"))
    org  <- (dtAll$Organization %>% unique)[6];org
    y=2018
    q <- (dtAll$QUESTION %>% unique)[2];q
    
    if (F) {
      dtAll[c(org,y,q)][,.N] # returns 33 lines (org,y, 33 questions)
      dtAll[as.list(org,y,q)]#        the same as above 
      dtAll[.(org,y,q)]  # returns 1 line -- CORRECT
      dtAll[Organization == org & SURVEYR==y & QUESTION==q] # the same as above    
    }
    
    for (org in dtAll[IDlevel > 0]$Organization %>% unique) {
      for (y in dtAll[Organization == org]$SURVEYR %>% unique){
        for (q in dtAll$QUESTION %>% unique) {
          myScore <- dtAll[.(org,y,q)]$SCORE100; myScore
          myRank <- dtAll[QUESTION==q & SURVEYR==y &  SCORE100 > myScore, .N] ; myRank
          TOTAL <- dtAll[QUESTION==q & SURVEYR==y , .N]; TOTAL
          dtAll[.(org,y,q), RANK100:=round(myRank/TOTAL*100)]
          # set(dtAll,QUESTION==q, RANK100:=round(RANK/TOTAL*100)]
        }
      }
      
    }
    
    if (F) {       # . validate and save  ----
      dtPSES[, .N, by=SURVEYR]
      dtPSES[1:2]
      dtPSES[LEVEL1ID==83, .N, by=.(SURVEYR, QUESTION, 
                                    LEVEL1ID, LEVEL2ID, LEVEL3ID, LEVEL4ID, LEVEL5ID)]
      dtPSES$QUESTION %>% unique
    }
    
    fwrite(dtPSES, "dtPSES.csv", sep="\t"); 
  }
}
#.  createPsesScores ()
if (F)
  createPsesScores ()


######################################################## #
######################################################## #
#readDataFromOpenCanada <- function() {
#strUrl2020 <- # 2018-2020
# "https://open.canada.ca/data/dataset/4301f4bb-1daa-4b50-afab-d1193b5d2284/resource/8bf75d4b-a80d-4828-839a-bf8c0b76af51/download/2020-public-service-employee-survey-open-dataset-ensemble-de-donnees-ouvertes-du-sondage-aupres-.csv"
#  NEVER read URL for now
# strUrlDocumentation2018 <- 
#   "https://www.canada.ca/content/dam/tbs-sct/documents/datasets/pses-saff/2018/2018_PSES_Supporting_Documentation_Document_de_r%C3%A9f%C3%A9rence_du_SAFF_2018.xlsx"
#    strUrl2018 <-.strUrl2018 
# "https://www.canada.ca/content/dam/tbs-sct/documents/datasets/pses-saff/2018/2018_PSES_open_dataset_Ensemble_de_donn%C3%A9es_ouvertes_du_SAFF_2018.csv"
# strUrl2017 <- 
#   "https://www.canada.ca/content/dam/tbs-sct/documents/datasets/pses-saff/2017/2017_PSES_SAFF_Open_dataset_Ensemble_donnees_ouvertes.csv"
# strUrl2014 <-
#   "https://www.canada.ca/content/dam/canada/tbs-sct/migration/psm-fpfm/modernizing-modernisation/pses-saff/source-data/2014-results-resultats.csv"
# strUrl2011 <- 
#   "http://www.tbs-sct.gc.ca/pses-saff/2011/source-data/PSES-SAFF2011_OverallPS.csv"

#}


############################################################################### #
############################################################################### #




# .......................................... -----




plotPSES.layout <- function (input) {
  ggplot(dtRESULT
         # dtRESULT[SURVEYR==input$year],
         # dtRESULT[IDlevel <=  getLevel(myID)+1],
  )  + 
    theme_bw() +
    # geom_text(aes(x,y, label=":("), data=data.table(x=40,y=ySmiley/2),size=6) +
    # geom_text(aes(x,y, label=":)"), data=data.table(x=60,y=ySmiley/2),size=6)  + 
    scale_x_continuous(breaks=(3:9)*10, limit=c(30,90)) +
    geom_vline(aes(xintercept=50), col="black", linetype=4) +
    labs(
      x="Score = Positive responses / All responses (%)",
      y=NULL,
      caption = paste0("Public Service Employee Survey Results\nLicense: Open Government Licence - Canada\n Generated", #  on ", format(Sys.time(), "%d %B, %Y"), 
                       " by iTrack (https://itrack.shinyapps.io/PSES)")
    ) 
}


################################################################### #
plotDepts_vs_Scores <-  function(input)  {
  
  
  
  if (T) {
    g <- plotPSES.layout(input) + 
      
      annotation_raster(image_smileys, xmin = 46, xmax = 54, ymin = 0.2, ymax = 1.8) +
      geom_vline(aes(xintercept=dtRESULT[SURVEYR==input$year & IDlevel==0]$SCORE100), linetype=4,  col="black") +
      #guides(colour = guide_legend("Public Service average")) +
      
      # geom_point(aes(SCORE100, Organization, col=SURVEYR),size=10, alpha=0.2) +
      geom_label(aes(SCORE100, Organization, 
                     label=ANSCOUNT,
                     fill=SURVEYR
      ), alpha=0.2) +
      ##guides(fill = guide_legend("Theme")) + 
      ## scale_fill_brewer(palette = "Blues")  
      # guides(size="none") +
      # guides(colour="none") +
      # guides(fill="none")
      guides(fill= guide_legend("SURVEY YEAR")) + 
      theme(legend.position = "bottom")   
  }
  
  g
}


################################################################### #
plotQuestions_vs_Scores <- function(input)  {
  # if (dtRESULT %>% nrow == 0)
  #   return (NULL)

  g <-  plotPSES.layout()  + 
    guides(col= guide_legend("Theme")) +  theme(legend.position = "bottom")  +    
    annotation_raster(image_smileys, xmin = 46, xmax = 54, ymin = 0, ymax = 5) +
    
    geom_point(data=dtRESULT[IDlevel==getLevel(myID)],mapping=aes(SCORE100, Question.Abbreviated, col=as.ordered(Theme)) , size=7, alpha=0.8) +
    
    geom_label(data=dtRESULT[IDlevel==getLevel(myID)],mapping=aes(SCORE100, Question.Abbreviated, label=RANK100) ,  alpha=0.4) +
    
    geom_point(data=dtRESULT[IDlevel==0],mapping=aes(SCORE100, Question.Abbreviated), 
               size=7,  shape=3, col="black") + # shape=15)
    
    
    geom_point(data=dtRESULT[as.integer(IDlevel)>getLevel(myID)],mapping=aes(SCORE100, Question.Abbreviated, col=as.ordered(Theme)), size=2, alpha=0.1) 
  # + 
  #   
  #   geom_point(data=dtRESULT[level==myLevel(id)+2],mapping=aes(SCORE100, Question.Abbreviated, col=as.ordered(Theme)), size=1, alpha=0.6) 
  #   
  #   
  
  # dtRESULT[ , Question.Abbreviated := as.character(Question.Abbreviated)]
  # 
  
  g
  
}

# ......................................... -----

readPsesData <- function ()  {
  # ... read *.csv ----
  #dtPSES <<- fread("dtPSES.csv")
  dtDepartments <<- fread("dtDepartments.csv")  
  setkeyv(dtDepartments,PSES_ID_COLS)
  dtQuestions <<- fread("dtQuestions.csv")
  dtQuestions <<- dtQuestions[Theme!="Phoenix & Pay issues"] 
  setkey(dtQuestions,QUESTION)
  
  #dtAll <<- fread("dtAll+rank+change2014.csv")  # dtAll+rank+change.csv
  dtAll <<- fread("dtAll+rank+change2011+2014.csv")  # dtAll+rank+change.csv
  
  # dtAll[SCORE_vs_2011==0, SCORE_vs_2011:=NA] <-- THIS CAUSES PROBLEM !!
  return (T)
  
  dtAll[LEVEL1ID==0 & LEVEL2ID==0 & LEVEL3ID==0 & LEVEL4ID==0 & LEVEL5ID ==0, ':='(IDlevel=0,pathString="GoC", AADD="GoC", Organization.fullname="Entire Public Service", Organization="Entire Public Service")]
  
  dtAll %>% names
  
  if (F) { # !! NO: i need this for printing !}
    dtAll$Organization.fullname <<- NULL
    dtAll$Organization <<- NULL
    dtAll$Question <<- NULL
    dtAll$Question.Abbreviated <<- NULL
    dtAll$Theme <<- NULL
  }
  
  return (T)
  
  dtAll <<- dtPSES[dtDepartments, on=PSES_ID_COLS][dtQuestions, on="QUESTION"]
  
  
  dtAll[is.na(AADD),.N] # 4 - related to Phoenix & Pay issues  - need to redo dtPSES to incluide Phoenix
  dtAll <<- dtAll[!is.na(LEVEL5ID)] # 4 - related to Phoenix & Pay issues 
  
  dtAll[Theme=="Phoenix & Pay issues"]
  
  if (F) {  
    # . handle multiple answers ---      # I found that there's no problem here:
    dtAll[ ,.N, by=.(SURVEYR,QUESTION,LEVEL1ID,LEVEL2ID,LEVEL3ID,LEVEL4ID,LEVEL5ID)][N>1] # 0 ! 
    
    dtAll[ ,.N, by=.(SURVEYR,QUESTION,Organization)][N>1] # 1979: 
    dtAll <<-  dtAll [, ':='(SCORE100=median(SCORE100) %>% as.integer(), ANSCOUNT=max(ANSCOUNT)) ,
                      by=.(SURVEYR,QUESTION,Organization)]
    dtAll <<- dtAll %>% unique(by=c("SURVEYR","QUESTION","Organization"))
    
  }
  
  #... assign rank (wrt All PS & Level=1 <-- TODO) to each (Org,Q,Year) ----  
  if (T) {
    
    
    dtAll$RANK_GoC <- 50
    dtAll$RANK_Agency <- 50
    
    setkey(dtAll, LEVEL1ID,LEVEL2ID,LEVEL3ID,LEVEL4ID,LEVEL5ID, SURVEYR, QUESTION)
    
    for (l1 in dtPSES$LEVEL1ID %>% unique()){
      if (l1==0) next
      for (l2 in dtPSES[LEVEL1ID==l1]$LEVEL2ID %>% unique()){
        
        for (l3 in dtPSES[LEVEL1ID==l1 & LEVEL2ID==l2]$LEVEL3ID %>% unique()){
          for (l4 in dtPSES[LEVEL1ID==l1 & LEVEL2ID==l2 & LEVEL3ID==l3]$LEVEL4ID %>% unique()){
            for (l5 in dtPSES[LEVEL1ID==l1 & LEVEL2ID==l2 & LEVEL3ID==l3 & LEVEL4ID==l4]$LEVEL5ID %>% unique()){
              
              for (y in dtPSES[LEVEL1ID==l1 & LEVEL2ID==l2 & LEVEL3ID==l3 & LEVEL4ID==l4 & LEVEL5ID==l5]$SURVEYR %>% unique()){
                for (q in dtQuestions$QUESTION) {
                  myScore <- dtAll[.(l1,l2,l3,l4,l5,y,q)]$SCORE100; myScore
                  if (is.na(myScore)) next
                  
                  myRank0 <- dtAll[QUESTION==q & SURVEYR==y &  SCORE100 > myScore, .N] ; myRank0
                  TOTAL0  <- dtAll[QUESTION==q & SURVEYR==y , .N]; TOTAL0
                  dtAll[.(l1,l2,l3,l4,l5,y,q), RANK_GoC:=round(myRank0/TOTAL0*100)]
                  
                  if (l2==0) next
                  
                  myRank1 <- dtAll[LEVEL1ID==l1 & QUESTION==q & SURVEYR==y &  SCORE100 > myScore, .N] ; myRank1 
                  TOTAL1 <- dtAll[LEVEL1ID==l1 & QUESTION==q & SURVEYR==y , .N]; TOTAL1
                  dtAll[.(l1,l2,l3,l4,l5,y,q), RANK_Agency:=round(myRank1/TOTAL1*100)]
                }
              }
            }
          }
        }
      }
    }
    
  }
  # ... assign gradient (change) ----
  if (F) {

    dtAll$NEW_OLD_SCORE <- 0L
    sapply(dtAll,typeof)
    #dtAll[, `NEW_OLD_SCORE`:=as.integer(`NEW_OLD_SCORE`)]
    
    setkeyv(dtAll,c("I","SURVEYR","QUESTION"))
    
    SURVEYR1 = 2018 
    SURVEYR2 = 2014
    
    for (i in dtAll$I %>% unique()) {
      for (q in dtQuestions$QUESTION) {
        if (  nrow (dtAll[i==I & QUESTION==q & SURVEYR==SURVEYR2]) > 0 &
              nrow (dtAll[i==I & QUESTION==q & SURVEYR==SURVEYR1]) > 0 )  {
          old <- dtAll[i==I & QUESTION==q & SURVEYR==SURVEYR2]$SCORE100
          new <- dtAll[i==I & QUESTION==q & SURVEYR==SURVEYR1]$SCORE100
          dtAll[i==I & QUESTION==q & SURVEYR==SURVEYR1, NOW_vs_2014_SCORE:=new-old]
        }
      }
    }
    
    dtAll[NEW_OLD_SCORE<0]   
    dtAll[NOW_vs_2014_SCORE<0]   
    dtAll[!is.na(NEW_OLD_SCORE)] 
    
  }
  bPSES_READ <<- T
  
  # ... save dtAll----
  
  setnames(dtAll, "NEW_OLD_SCORE", "SCORE_vs_2011")
  setnames(dtAll, "NOW_vs_2014_SCORE", "SCORE_vs_2014")
  
  # problem  appeared after Idid this:
  if (F) {
    dtAll[str_length(pathString)<1 & IDlevel <5] 
    
    #TODO ORG_1  LEV_2  ORG_2  LEV_3  ORG_3  LEV_4  ORG_4 -> LEV_5 ORG_5
    dtAll[AADD=="N/A", pathString:="I cannot find"] 
    dtAll[SCORE_vs_2011==0, SCORE_vs_2011:=NA]
  }
  
  fwrite(dtAll, "dtAll+rank+change2011+2014.csv",  sep="\t")
}




# .......................................... -----
# 
# _______TEST IT _______ ####


testPsesData <- function () {
  
  # .. readPsesData() ----
  # if (bPSES_READ == F) {
  readPsesData() 
  pses.selectInput ()
  input  
  # }
  
  if  (T) {
    dtAll[, .N, by = SURVEYR] %>% print 
    #   SURVEYR     N
    #       <int> <int>
    # 1:    2008   660
    # 2:    2011  1295
    # 3:    2014  1992
    # 4:    2017  2372
    # 5:    2018 68094
    
    dtQuestions
    dtQuestions$Theme %>% unique() %>% print#
    dtAll$Theme %>% unique() %>% print#
    dtDepartments 
    
  }
 
  
  # .. input$question ----
  
  # dtResultsAll <<- dtAll[QUESTION==myQ & SURVEYR==myYear]; 
  dtResultsAll <<- dtAll[Question.Abbreviated==input$question]; 
  
  
  # .. input$level1, ...  ----
  
  if (F) {
    #TODO: use purrr to do it with a function for all levels
    input$level5 <- as.integer( input$level5 ) 
    if (is.na(input$level5)) input$level5 <- 0
    input
  }
  
  myID=c(input$level1,input$level2,input$level3,  input$level4,input$level5)
  
  setkeyv(dtResultsAll, PSES_ID_COLS)  
  dtRESULT <<- dtResultsAll[as.list(myID)] 
  dtRESULT
  
  # .. input$showchildren: dtResultsBelow----
  
  if (input$showchildren) {
    setkeyv(dtResultsAll, PSES_ID_COLS[1:(which.min(myID)-1)])

    dtRESULT <<- dtResultsAll[as.list(myID[1:(which.min(myID)-1)])] %>% 
      rbind(dtRESULT)
  }
  
  # .. input$showparents: dtResultsAbove----
  if (input$showparents) {

    dtRESULT <<- dtResultsAll[
      (LEVEL1ID == 0 | LEVEL1ID == myID[1] ) & 
        (LEVEL2ID == 0 | LEVEL2ID == myID[2]) & 
        (LEVEL3ID == 0 | LEVEL3ID == myID[3]) & 
        (LEVEL4ID == 0 | LEVEL4ID == myID[4] )& 
        (LEVEL5ID == 0 | LEVEL5ID == myID[5]  ) 
      ] %>% rbind(dtRESULT)
  }
  
  dtRESULT <<- dtRESULT %>% unique()
  setkeyv(dtRESULT,COLS_PSES)
  dtRESULT
  
  
  #sapply(dtRESULT,typeof)
#  dtRESULT[, SURVEYR:=as.ordered(SURVEYR)]
  
  
  # .. input$sortby -----
  if (input$sortby =="name"){
    dtRESULT[ , Organization := reorder(Organization, Organization)]
    dtRESULT[ , Organization := reorder(Organization, IDlevel)]
  } else if (input$sortby =="number of responses"){
    dtRESULT[ , Organization := reorder(Organization, ANSCOUNT)]
    dtRESULT[ , Organization := reorder(Organization, IDlevel)] 
  } else if (input$sortby =="score"){
    dtRESULT[ , Organization := reorder(Organization , -SCORE100) ]
    dtRESULT[ , Organization := reorder(Organization , IDlevel)]
  } else { # (input$sortby =="rank"){ 
    dtRESULT[ , Organization := reorder(Organization , -RANK_GoC) ]
    dtRESULT[ , Organization := reorder(Organization , IDlevel)]
  } 
  
  
  # .. input$overlay -----
  
  if (input$overlay =="name"){
    dtRESULT[ , overlay := AADD]
  } else if (input$overlay =="number of responses"){
    dtRESULT[ , overlay := ANSCOUNT]
  } else if (input$overlay =="score"){
    dtRESULT[ , overlay := SCORE100]
  } else if (input$overlay =="rank"){ 
    dtRESULT[ , overlay := RANK_GoC]
  } else if (input$overlay =="rankAgency"){ 
      dtRESULT[ , overlay := RANK_Agency]
  } else if (input$overlay =="year"){ 
    dtRESULT[ , overlay := SURVEYR]
  } else { #nothing
    dtRESULT[ , overlay := ""]
  }
  
  
  
  # .. filterbyrank -----
  
  if (F) {
  if (input$level3>0)  {
    dtRESULT <<- dtRESULT [RANK_Agency< input$filterbyrank[2] & RANK_Agency >input$filterbyrank[1] ]
  } else {
    dtRESULT <<- dtRESULT [RANK_GoC < input$filterbyrank[2] & RANK_GoC >input$filterbyrank[1] ]
  }
  
  }
  
  # .. filterbygradient -----  
  if (F) {
    dtRESULT <<- dtRESULT [SCORE_vs_2011 < input$filterbygradient[2] & SCORE_vs_2011 >input$filterbygradient[1] ]
  }
  
  # .. yearsToShow -----    
  
  # dtRESULT <<- dtRESULT[SURVEYR == 2018 | SURVEYR == ifelse(input$yearsToShow)]
  # 
  
  
  
  # __BY DEPARTMENTS__ --------------------------------
  
  plotDepts_vs_Scores(input) + 
    labs(
      title=dtQuestions[QUESTION == myQ]$Question, 
      #title=paste0(input$year, " Public Service Employee Survey Results"),
      # subtitle=paste0(dtQuestions[Question == input$question]$Question,"\n(Number of responses is indicated in the box)"),
      subtitle=paste0(input$year, " Public Service Employee Survey Results (Number of responses is indicated in the box)")
      # 
      #paste("Department:", dtDepartments[as.list(myID)]$Organization, "(Number of responses is indicated in the box)"),
      
    )  
  
  
  dt <- dtRESULT[ , .(ORG_1, ORG_2,ORG_3,ORG_4, SCORE100, sep = "/")][, pathString:=paste(ORG_1, ORG_2,ORG_3,ORG_4, SCORE100, sep = "/")] 
  
  dtRESULTtree <- as.Node(dt)
  
  print(dtRESULTtree, limit=NULL) 
  
  
  
  setkeyv(dtDepartments,COLS_PSES)
  
  myID=c(input$level1,input$level2,input$level3,  input$level4,input$level5)
  
  
  dt <- dtDepartments[ as.list(myID )]
  #   dt <- dtDepartments[ .(c(id1(),id2(),id3(),id4(),id5() ) )]
  sprintf("Level: %i. %s (%s, ID=%i.%i.%i.%.i.%i)" , 
          dt$IDlevel, dt$Organization, dt$pathString, 
          input$level1,input$level2,input$level3,  input$level4,input$level5)
  # id1(),id2(),id3(),id4(),id5())
  
  DT::datatable(
    dtRESULT[, .(IDlevel,pathString,SURVEYR,SCORE100,ANSCOUNT)],
    options = list(
      bPaginate = T,
      pageLength = 12
    )
  )
  
  
  # __BY QUESTION__ -----------------------------------
  
  Questions_vs_Scores(input) +
    
    labs(
      title=paste(input$year, "Public Service Employee Survey Results"), 
      subtitle=paste0("Department: ",
                      # "Department:", dtDepartments[as.list(myID)]$pathString, 
                      dtDepartments[as.list(myID)]$Organization,
                      " (Ranking percentile is indicated in the box, Public Service average is marked by cross)")
    ) 
  
  
  dt <- dtDepartments[ as.list(c(id1(),id2(),id3(),id4(),id5() ) )]
  #   dt <- dtDepartments[ .(c(id1(),id2(),id3(),id4(),id5() ) )]
  sprintf("Level: %i. %s (%s, ID=%i.%i.%i.%.i.%i)" , 
          dt$IDlevel, dt$Organization, dt$AADD, 
          id1(),id2(),id3(),id4(),id5())
  
  
  DT::datatable(
    #r.dtAll(),
    dtRESULT[, .(SURVEYR,QUESTION,IDlevel, pathString,SCORE100,ANSCOUNT)],
    options = list(
      bPaginate = T,
      pageLength = 10
    ))
  
}

if(F) {
  readPsesData()
  
  
  
  dt <- getResultsParents (id=c(0,0,0,0,0), nQ = "Q43", aYears=c(2018))
  dt <- getResultsParents (id=c(83,0,0,0,0), nQ = "Q43", aYears=c(2018))
  
  
  ### PROBLEM when using  fread("dtPSES-2011.csv") # 29.5 Mb . In dtPSES.csv I removed all <2018
  getResultsParents (id=c(83,200,304,0,0),nQ = "Q43", aYears=c(2018,2011))
  getResultsParents (id=c(83,200,0,0,0), nQ = "Q43", aYears=c(2011,2018))
  getResultsParents (id=c(83,0,0,0,0), nQ = "Q43", aYears=c(2011,2018))
  
  # NO PROBLEM:
  getResultsParents (id=c(83,200,304,0,0),nQ = "Q43", aYears=c(2018))
  getResultsParents (id=c(0,0,0,0,0), nQ = "Q43", aYears=c(2011,2018))
  
  
  
  dt <- getResultsParents (id=myID, nQ = "Q43", aYears=c(2018))
  
  dt <- 
    getResultsParents (id=myID, nQ = dtQuestions[Theme %in% "Overall Environment"]$QUESTION, aYears=c(2018))
  
  dt
  dt[,.(SURVEYR,QUESTION,AADD,BB_DD,SCORE100,ANSCOUNT)]
  
}


# _______USEFUL BITS _______ ####


# . data.tree -----

buildOrgChartTree <- function() { 
  
  
  dtRESULT[ , pathString:=paste(LEVEL1ID, LEVEL2ID,LEVEL3ID,LEVEL4ID,LEVEL5ID, SCORE100, sep = "/")]
  # dtRESULT[, LEVEL5ID:=SCORE100]
  
  dtRESULTtree <- as.Node(dtRESULT)
  print(dtRESULTtree,"SURVEYR", "QUESTION") 
  plot(dtRESULTtree) 
  
}

if (F){
  library(data.tree)
  
  year=2018; nQ="Q43"
  dtPSES0 <- dtPSES [as.list(83,200,304,0,0)][SURVEYR == year & QUESTION == nQ]
  
  dtPSES0[ , pathString:=paste("NHQ", LEVEL4ID,LEVEL5ID, sep = "/")]
  
  treePSES0 <- as.Node(dtPSES0)
  print(treePSES0, "SCORE100", "ANSCOUNT", limit = 100)
  
  plot(treePSES0)
  
}



